// 1.这里先使用了 2 那里创建的 ProjectVersion 类
//version = new ProjectVersion(0, 1, true)
// 2
class ProjectVersion {
    Integer major
    Integer minor
    Boolean release

    ProjectVersion(Integer major, Integer minor) {
        this.major = major
        this.minor = minor
        this.release = Boolean.FALSE
    }

    ProjectVersion(Integer major, Integer minor, Boolean release) {
        this(major, minor)
        this.release = release
    }

    @Override
    String toString() {
        "$major.$minor${release ? '' : '-SNAPSHOT'}"
    }
}

// Gradle 构建生命周期阶段 初始化阶段->配置阶段->执行阶段。没有定义动作或者使用左移操作符的部分，Gradle 称之为 task 配置
// 注意：项目每一次构建的的时候任何配置代码都会被执行，即使你只执行 gradle tasks

// Project 接口提供了 file 方法；它会创建一个相对于项目目录的 java.io.File 实例
ext.versionFile = file('version.properties')

// 没使用左移操作符定义 task 配置
task loadVersion {
    println "配置阶段执行的代码 loadVersion"
    project.version = readVersion()
}

ProjectVersion readVersion() {
    logger.quiet 'Reading the version file'

    if (!versionFile.exists()) {
        throw new GradleException("Required version file does not exist: $versionFile.canonicalPath")
    }
    Properties versionProps = new Properties()
    versionFile.withInputStream { stream ->
        versionProps.load(stream)
    }

    // 在 Groovy 中，如果 return 是方法中最后一条语句的话，则可以将它省略
    new ProjectVersion(versionProps.major.toInteger(), versionProps.minor.toInteger(), versionProps.release.toBoolean())
}

task printVersion {
    println "配置阶段执行的代码 printVersion1"
    doFirst {
        println "执行阶段执行的代码 打印版本 $version"
    }
    println '配置阶段执行的代码 printVersion2'
}